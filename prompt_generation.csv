Task Title,Smart Contract Description
Simple Storage: Store and update a single integer value,"This smart contract is designed to store a single unsigned integer value on the blockchain. The stored value represents a simple piece of state that can be read by external users and updated under controlled conditions.

The contract maintains one state variable of type unsigned integer, which is initialized when the contract is deployed (either to a default value such as zero or to a value provided at deployment time).

The contract provides a public read function that allows anyone to retrieve the currently stored value without modifying the blockchain state. This function does not require special permissions and does not consume gas when called externally as a view operation.

To modify the stored value, the contract includes an update function that accepts a new unsigned integer as input and replaces the existing value with the new one. This update operation is restricted to authorized users only. Typically, authorization is enforced by assigning an owner or administrator at deployment time and allowing only this account (or a predefined set of accounts) to perform updates.

The update function should include appropriate access control checks to prevent unauthorized modification of the stored value. If an unauthorized user attempts to update the value, the transaction must be rejected.

The contract clearly defines visibility for all variables and functions, exposing only what is necessary for interaction while keeping internal logic protected. Overall, the contract demonstrates basic state storage, controlled state modification, and safe read access on the blockchain."
Ownership Management: Owner-based access control,"This smart contract manages ownership of the contract by tracking a single owner address and enforcing access control based on that ownership.

At the time of deployment, the contract assigns an initial owner. This owner is typically the account that deploys the contract, unless a different address is explicitly provided during deployment. The owner represents the authority responsible for managing privileged operations within the contract.

The contract exposes a public read-only function that allows any user to query and verify the current owner address. This function does not modify the blockchain state and can be called freely without restrictions.

Ownership transfer is supported through a dedicated function that allows the current owner to assign ownership to a new address. Only the existing owner is permitted to initiate this transfer. If any other address attempts to call the ownership transfer function, the transaction must be rejected.

When transferring ownership, the new owner address must be valid and not the zero address. Upon a successful transfer, the contract updates its internal record to reflect the new owner, and all future access-controlled operations recognize this new owner as the sole authorized entity.

The contract enforces strict access control rules to ensure that only the current owner can perform ownership-sensitive actions. Unauthorized calls to restricted functions are expected to fail and leave the contract state unchanged.

Overall, the contract provides a minimal and clear ownership model, ensuring transparent ownership tracking, secure transfer of control, and predictable behavior throughout its lifecycle."
Ether Piggy Bank: Deposit and withdraw Ether,"This smart contract enables users to deposit Ether into the contract and later withdraw their funds according to clearly defined rules. The contract acts as a simple on-chain vault that securely tracks individual user balances.

When a user sends Ether to the contract, the contract records the deposit by increasing the sender’s internal balance. Each user’s balance is tracked separately, typically using a mapping that associates blockchain addresses with the amount of Ether they have deposited. Deposits can be made multiple times, and each new deposit increases the user’s existing balance.

The contract provides a withdrawal function that allows users to withdraw Ether from the contract. Only the user who owns a particular balance is allowed to withdraw funds from that balance. Users cannot withdraw more Ether than they have deposited, and they cannot withdraw funds belonging to other users.

Before processing a withdrawal, the contract checks whether the caller has a sufficient balance to cover the requested withdrawal amount. If the balance is sufficient, the contract reduces the user’s recorded balance by the withdrawn amount and then transfers the corresponding Ether to the user’s address.

If a user attempts to withdraw more Ether than their recorded balance, or if they have no balance at all, the withdrawal request is rejected and the contract state remains unchanged. Similarly, if any other withdrawal condition fails, the transaction does not proceed and no Ether is transferred.

The contract ensures clear separation of user funds, enforces strict balance checks, and guarantees that Ether can only be withdrawn by the rightful depositor under valid conditions."
Simple Voting: Vote counting on predefined options,"This smart contract implements a simple on-chain voting system for a fixed set of predefined options. Its purpose is to allow eligible users to cast a single vote and to count votes transparently and reliably.

Before deployment, a list of valid voting options is defined. These options do not change during the lifetime of the contract. Each option has an associated vote count that starts at zero when the contract is deployed.

The contract defines rules for voting eligibility. Any address that meets the eligibility criteria is allowed to participate in the vote. At minimum, an eligible voter must not have voted before. The contract tracks whether an address has already voted and prevents duplicate voting by the same address.

To cast a vote, an eligible user selects one of the predefined options. The contract verifies that the selected option is valid and that the user has not already voted. If both conditions are satisfied, the contract records that the user has voted and increments the vote count for the chosen option.

If a user attempts to vote more than once, or tries to vote for an option that is not predefined, the transaction is rejected and no changes are made to the contract state.

The contract provides read-only functions that allow anyone to view the total number of votes for each option at any time. Voting results are determined by comparing the vote counts of all options. The option with the highest number of votes is considered the winning option. In the event of a tie, the contract simply reflects equal vote counts, leaving tie resolution to off-chain interpretation or predefined external rules.

Overall, the contract ensures fair voting by enforcing one vote per eligible address, accurate vote counting, and transparent access to results."
Message Board: Public message posting,"This smart contract functions as a public message board on the blockchain, allowing users to post messages that can be read by anyone.

The contract maintains a collection of messages stored on-chain. Each message consists of the text content provided by a user, along with metadata such as the sender’s address and the time at which the message was posted. Messages are stored in the order they are submitted so that the full posting history can be preserved and accessed sequentially.

Any user is allowed to post a message by calling the message submission function and providing the message content. When a message is posted, the contract records the message and permanently adds it to the stored collection. Once stored, messages cannot be edited or deleted, ensuring transparency and immutability.

The contract provides read-only functions that allow anyone to retrieve messages. Users can access individual messages by index or query the full list of messages, depending on the interface design. Reading messages does not modify the blockchain state and does not require special permissions.

To prevent abuse or unintended usage, the contract may enforce basic restrictions on posting. For example, it may reject empty messages, enforce a maximum message length, or require the sender to pay a small fee to discourage spam. If a message violates these rules, the posting transaction is rejected and no message is stored.

Overall, the contract enables open and permanent public communication on the blockchain by securely storing user-submitted messages and making them freely accessible for reading by all participants."
Crowdfunding: Goal-based fundraising,"This smart contract implements a crowdfunding mechanism that allows multiple users to contribute Ether toward a predefined funding goal within a fixed time period.

Contributors can send Ether to the contract at any time before the deadline. Each contribution is recorded by the contract, tracking how much Ether each contributor has provided in total. The contract maintains the cumulative amount of funds raised and continuously compares it against the funding goal.

If the total amount of Ether raised reaches or exceeds the funding goal before or by the deadline, the crowdfunding campaign is considered successful. In this case, the contract enables the project owner to withdraw the collected funds. Once withdrawn, the campaign is finalized, and contributors are no longer able to claim refunds or make additional contributions.

If the deadline passes and the total funds raised do not meet the funding goal, the campaign is considered unsuccessful. In this scenario, contributors are entitled to recover their contributions. Each contributor can individually request a refund, and the contract returns the exact amount of Ether they contributed. Refunds are handled on a per-contributor basis and do not affect the ability of other contributors to withdraw their own funds.

The contract ensures that:

* Contributions are only accepted before the deadline.
* Funds are locked in the contract until the campaign is either successful or declared unsuccessful.
* Only the owner can withdraw funds after a successful campaign.
* Contributors can only withdraw refunds if the funding goal is not reached.
* Each withdrawal or refund is tracked to prevent duplicate claims.

The contract focuses solely on managing contributions, determining campaign success or failure, and securely handling withdrawals based on the outcome."
Simplified Token: ERC20-like token logic,"This smart contract defines a simplified fungible token system that allows users to hold, transfer, and manage a fixed or controlled supply of tokens. The contract maintains an internal record of token balances for each user address and enforces rules governing how tokens can be moved and managed.

The contract starts with an initial total token supply that is created at deployment and assigned to a designated owner or initial holder. The total supply represents the sum of all tokens in circulation and is tracked by the contract at all times. The contract ensures that the total supply remains consistent with all balance changes unless explicitly adjusted through defined supply management actions.

Token holders can transfer tokens to other users by specifying a recipient and an amount. Before a transfer is executed, the contract verifies that the sender has a sufficient token balance. When a transfer occurs, the sender’s balance is reduced by the transfer amount and the recipient’s balance is increased by the same amount, preserving the overall total supply.

The contract enforces the following constraints:

* Transfers cannot exceed the sender’s available balance.
* Transfers to invalid or restricted addresses are not allowed.
* Token balances cannot become negative.

Basic supply management is supported through controlled actions, such as increasing or decreasing the total supply. These actions are restricted to an authorized entity, typically the contract owner. When new tokens are created, they are added to both the total supply and the balance of a designated account. When tokens are removed from circulation, the total supply is reduced accordingly, and the corresponding balances are updated to reflect the decrease.

The contract provides transparency by allowing users to view balances and the total token supply at any time. It focuses on core token behavior—balance tracking, secure transfers, and limited supply control—without implementing advanced features such as allowances or delegated transfers."
Whitelist Access: Permission-based actions,"This smart contract includes a whitelist mechanism that restricts access to specific actions so that only approved addresses are permitted to perform them. The whitelist represents a set of addresses that the contract recognizes as authorized participants.

Certain sensitive or privileged actions within the contract can only be executed by addresses that are currently on the whitelist. When a user attempts to perform one of these restricted actions, the contract checks whether the caller’s address is included in the whitelist. If the address is not whitelisted, the action is rejected and no state changes occur.

The authority to manage the whitelist is assigned to a designated controller, typically the contract owner or an administrator defined at deployment. This controller has exclusive permission to add new addresses to the whitelist or remove existing ones. Adding an address grants it immediate permission to perform whitelisted actions, while removing an address immediately revokes those permissions.

The contract ensures that:

* Only the authorized controller can modify the whitelist.
* Whitelisted status is checked each time a restricted action is requested.
* Addresses that are not whitelisted cannot bypass the access restrictions.

The whitelist mechanism provides a controlled way to limit participation, enforce access rules, and maintain security by ensuring that only explicitly approved addresses can carry out protected operations."
Payment Splitter: Split Ether among recipients,"This smart contract accepts incoming Ether payments and automatically allocates the received funds among a fixed set of recipients according to predefined shares or percentages assigned to each recipient.

Whenever Ether is sent to the contract, the total amount received is conceptually split based on these predefined shares. Each recipient is entitled to a proportional portion of the payment that corresponds to their assigned percentage or weight. The contract keeps track of how much Ether each recipient is owed over time, rather than immediately transferring funds upon receipt.

Recipients can withdraw their allocated funds individually. When a recipient initiates a withdrawal, the contract calculates the amount owed to that recipient based on all payments received so far minus any amounts previously withdrawn. The contract then transfers the owed Ether to the recipient and updates its internal records to prevent double withdrawals.

The contract ensures that:

* Funds are distributed fairly according to the predefined shares.
* Each recipient can only withdraw their own allocated portion.
* Withdrawals do not affect the balances of other recipients.

The contract does not define how recipients or shares are modified; it only describes how incoming Ether is split and how recipients claim their funds."
Simple Escrow: Buyer–seller escrow,"This smart contract acts as an escrow agreement between three parties: a buyer, a seller, and an arbiter. Its purpose is to securely hold funds during a transaction and release them based on predefined conditions and approvals.

The buyer deposits Ether into the contract to initiate the escrow. Once the funds are deposited, they are locked within the contract and cannot be accessed directly by either the buyer or the seller without following the escrow process.

The seller becomes eligible to receive the funds when the agreed conditions of the transaction are met, such as confirmation that goods or services have been delivered. The buyer may signal approval to release the funds to the seller, indicating successful completion of the agreement.

If a dispute arises or the transaction conditions are not met, the arbiter plays a neutral decision-making role. The arbiter has the authority to resolve disputes by deciding whether the funds should be released to the seller or refunded to the buyer.

In the case of a refund, the contract returns the deposited Ether to the buyer. In the case of a successful completion, the contract transfers the escrowed funds to the seller. Once the funds are released or refunded, the escrow is considered complete and cannot be reused.

The contract ensures that:

* Funds remain securely locked until a valid release or refund condition is satisfied.
* Neither party can unilaterally access the funds once deposited.
* The arbiter provides a trusted resolution mechanism in the event of a dispute."
